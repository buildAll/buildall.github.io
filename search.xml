<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何与孩子一起玩乐高</title>
      <link href="/2017/09/11/howtoplaylegowithkids/"/>
      <url>/2017/09/11/howtoplaylegowithkids/</url>
      
        <content type="html"><![CDATA[<img src="/images/lego.jpg" class=""><p>周末和四岁的儿子一起玩了乐高，很有意思，并且觉得有些经验可以总结和分享的。</p><p>这篇文章主要说以下两点内容:</p><ol><li>我是怎么为孩子 <strong>选择乐高</strong> 玩具的</li><li>我是怎么__引导孩子__正确的完成乐高玩具的拼装</li></ol><blockquote><p>乐高玩具大概可以分为两类: 自由拼装和按照图纸安装成特定玩具。<br>本文中说的乐高玩具都是后者，既按照图纸安装的乐高。</p></blockquote><h2 id="怎么选乐高玩具"><a href="#怎么选乐高玩具" class="headerlink" title="怎么选乐高玩具"></a>怎么选乐高玩具</h2><p>乐高玩具那么多，有各种动漫、电影、主题、建筑类的乐高，我们应该怎么给孩子选择乐高呢？我总结了四点:</p><ol><li>带着孩子一起去选</li><li>选择孩子兴趣相关的乐高</li><li>(在确保安全的情况下)所选择的乐高玩具上标注的推荐年龄段应当高于孩子的实际年龄</li><li>尽量买一套玩具、多种拼法的乐高</li></ol><p>带着孩子一起去选的话，可以让孩子自己完成最后买哪一个的决定，这样既能一定程度上保证买到的乐高玩具是孩子所喜欢的，也能让他对自己的选择承担起责任，在后面拼的时候更能坚持到底，因为毕竟是自己选的嘛。</p><p>选孩子兴趣相关的乐高。这点的好处显而易见，感兴趣的东西孩子更能坚持下去把它拼出来。比如我家小孩对工程类汽车就特别感兴趣，所以我们买了一套翻斗车+拖车+挖掘机的乐高，然后孩子在拼的过程中，有畏难情绪时，只要跟他说类似“再拼一会儿就能装轮胎、开动了”，他就能继续“工作”了。</p><p>乐高玩具上有类似”3-5”、”8-12”之类的推荐年龄段，同时在包装上还会写有类似”本玩具含有微小零件，不适合三岁以下儿童”这样的提示。其中推荐年龄段可以看作是这套乐高的“难度系数”，而“不适合三岁以下”的提示可以看作玩具的安全系数。所以选择时我们务必要确保安全系数达标，然后在此基础上尽可能选难度系数高的。选难度系数高的好处是:</p><ol><li>让孩子通过玩的过程，认识到自己的潜力，提高自信心</li><li>让孩子学会解决困难的问题，明白再困难的问题，只要找到方法，都可以解决</li><li>让陪玩的大人更投入。太过幼稚的话，大人在陪玩过程中难免昏昏欲睡</li></ol><blockquote><p><strong>选难度系数太大的，孩子能拼起来吗？</strong><br> 首先，我想说的是，乐高是一款全球性的玩具，他的每一款玩具几乎都是针对全球市场的。因此，在标注推荐年龄段时，乐高公司会考虑到全球儿童的智力发展水平，而华人作为世界智商最高的种族之一，儿童的平均智商一定是高于同年龄段的大多数其他民族的儿童的(不是种族歧视哦，每个民族有自己的特长)，因此我们不必太在意难度系数。其次，其实无论是多高难度系数的乐高，其拼装的方法都是大同小异的，只要掌握了方法、步骤，就能完成拼装，难度系数到了一定程度之后，差别主要体现在“方法、步骤”重复的次数上。(后面我会提到适合孩子的、具体的拼装方法)</p></blockquote><p>还有就是我们尽可能买一套__N in 1__的乐高。这样做的好处主要是增加可玩性、提高玩具的性价比。就像上文提到的，我这次买的是翻斗车+拖车+挖掘机的，这三辆车都在一套乐高里，在拼的过程中，孩子需要分别拼装三辆车，然后三辆车所有的零件合起来还可以拼成一辆推土车，相当于一套乐高里包含了四辆车，这样一套乐高，比起相同价位的、只能拼出一种汽车的乐高来说，可玩性、性价比那自然是高出不少。</p><h2 id="让孩子能自己拼装乐高的方法"><a href="#让孩子能自己拼装乐高的方法" class="headerlink" title="让孩子能自己拼装乐高的方法"></a>让孩子能自己拼装乐高的方法</h2><p>让孩子能(最终独立)拼装出乐高的关键，我觉得是告诉他方法。具体来说就是:</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>有一块足够大的、平整的地方(地板)。如果在桌子上拼，零件有可能会掉下来、乱蹦到各处，找起来很麻烦。</li><li>拼之前将所有零件按颜色分类分别放在地上或小盒子中。</li></ol><h3 id="教孩子如何使用图纸"><a href="#教孩子如何使用图纸" class="headerlink" title="教孩子如何使用图纸"></a>教孩子如何使用图纸</h3><ol><li>让孩子学会翻图纸，跟孩子强调要一页一页的翻</li><li>让孩子知道如何看图纸。一页图纸上通常会有一到二步拼装步骤，不能跳步，要一步步的拼。</li></ol><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>通常乐高图纸上的一步可以分为零件区，零件组装为”部件”的步骤，部件安装示意图。要教会孩子严格按照这样的步骤来组装:</p><ol><li>看零件区，看看这一步需要哪些零件、每种零件需要几个。</li><li>取零件。因为之前已经把零件按颜色分类，所以先看所需零件是什么颜色的，然后再去对应颜色的零件里去找所需零件。</li><li>确认零件都找全了。</li><li>看部件安装示意图，将零件组装为部件。这一步的关键是要提示孩子注意细节，比如零件的正反、方向。</li><li>组装完部件之后要对照图纸检查，确认没有错。</li><li>然后将部件按照图纸安装到主件中。</li><li>对照图纸，检查，确认安装正确。</li><li>翻到下一页或看下一步，开始重复1。</li></ol><blockquote><p>写过代码的可能会发现，这里的拼装步骤其实也很像我们平时写代码的过程</p></blockquote><ol><li>根据需求，分解出我们的程序需要哪些对象(或模块、组件)</li><li>开发对象</li><li>测试对象</li><li>使用对象完成特定功能</li><li>测试功能</li></ol><h3 id="家长的作用"><a href="#家长的作用" class="headerlink" title="家长的作用"></a>家长的作用</h3><ol><li>只要孩子能够按照这个步骤来，一般都能拼对。但是小孩的问题就是通常都不能严格执行这些步骤，他会取不齐零件、该检查的时候不检查。家长的作用就是不断提醒孩子零件是否找全，检查一下拼的对不对。</li><li>孩子力气比较小，家长可以帮忙安装一些较紧的零件。这里需要注意的是家长只出力，要让孩子描述零件一个怎么组装、插在哪一个洞洞里。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>和孩子一起组装乐高是一件很有意思的事情，不仅能增进家长和孩子之间的感情，还可以锻炼孩子:</p><ol><li>观察能力。安装过程中孩子需要不断比对自己拼的东西和图纸上的差异、观察图纸上的细节。</li><li>表达能力。在需要家长帮忙时，孩子需要描述自己遇到的问题。</li><li>提升对数字的认知。取零件时，有的零件可能需要好几个，这时候孩子不仅要自己认出图纸上的数字，还要数出自己取的零件个数和图纸上的数字是否相等。有些零件需要插入特定的洞洞里，这时孩子会数插入到第几个洞洞里。</li><li>动手能力。每一个细小的零件都需要他自己动手安装上去。</li><li>培养耐心。</li><li>培养解决问题的自信心。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 和代码无关的生活 </category>
          
          <category> lego </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lego </tag>
            
            <tag> 乐高 </tag>
            
            <tag> 亲子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo是怎么工作的</title>
      <link href="/2017/08/20/howhexoworks/"/>
      <url>/2017/08/20/howhexoworks/</url>
      
        <content type="html"><![CDATA[<img src="/images/howhexoworks/hexo_logo.png" class=""><p>你可能用过hexo(或者jekyll)来搭建自己的博客网站。通常我们在安装、配置完成hexo之后，借助hexo，一般通过以下步骤，就可以完成一篇博客的编写及发布，真是方便极了：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo init           // 创建一个新的hexo项目</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo new mynewblog  // 新建一篇标题为mynewblog的文章</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo server         // 为hexo在本地起一个http server, 然后通过浏览器访问博客</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo generate       // 生成将要发布的博客网站包含html在内的静态资源</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo deploy         // 将generate的结果发布到_config.yml中指定的仓库</span></span><br></pre></td></tr></table></figure><p>可是，从hexo init到hexo deploy中间发生了什么呢？为了搞清楚这一过程、理解hexo的工作原理，本文将试着回答以下问题:</p><ul><li>命令行中的hexo是什么</li><li>hexo是怎么将我们写好的markdown转换成html的</li><li>hexo插件是如何工作的</li><li>本地的hexo项目和git page有什么关系</li></ul><p>本文<strong>不是</strong>:</p><ul><li>hexo的安装、使用教程</li><li>git page的使用教程</li></ul><h2 id="命令行中的hexo是什么"><a href="#命令行中的hexo是什么" class="headerlink" title="命令行中的hexo是什么?"></a>命令行中的hexo是什么?</h2><p><a href="https://github.com/hexojs/hexo">hexo</a>项目在github上已经有超过17k的star了，但是你知道吗，日常我们在命令行”操作”hexo时所输入的<strong>hexo</strong>(例如hexo init)并不是这个17k个star的项目! 是的，我们在命令行中所输入的”hexo”实际是<a href="https://github.com/hexojs/hexo-cli/tree/master/lib"><strong>hexo-cli</strong></a>项目，该项目在github上的star还不足50个。</p><blockquote><p>hexo可以粗略分为三个子项目，分别是:</p><ul><li>hexo-cli</li><li>hexo (下文中用hexo core来指代)</li><li>hexo plugins</li></ul><p>其中hexo plugins不是指某一个单独的项目，而是泛指所有的hexo plugin项目。</p><p>请看下图:</p><img src="/images/howhexoworks/hexo_projects.png" class=""><p>让我们结合这张图来大致看看这三个项目的作用(下面的链接均是指向Github中相关的源码):</p></blockquote><ul><li><strong>hexo-cli</strong>: hexo命令行项目，作用是:<ol><li>启动hexo命令(进程)，及其参数<a href="https://github.com/hexojs/hexo-cli/blob/5e0969ffa64dec427428a245ab2d65beaf23123b/lib/hexo.js#L49">解析</a>机制。每次我们输入’hexo xxx’命令后，都会通过node调用hexo-cli中的<a href="https://github.com/hexojs/hexo-cli/blob/5e0969ffa64dec427428a245ab2d65beaf23123b/lib/hexo.js#L13">entry函数</a>(比如，可以把’hexo init’视为’node hexo-cli&#x2F;entry.js init’)</li><li>实现hexo命令的<a href="https://github.com/hexojs/hexo-cli/tree/master/lib/console">三个初始参数(功能)</a>: init &#x2F; version &#x2F; help</li><li><a href="https://github.com/hexojs/hexo-cli/blob/5e0969ffa64dec427428a245ab2d65beaf23123b/lib/hexo.js#L85">加载</a>hexo核心模块，并<a href="https://github.com/hexojs/hexo-cli/blob/5e0969ffa64dec427428a245ab2d65beaf23123b/lib/hexo.js#L47">初始化</a></li></ol></li><li><strong>hexo core</strong>: hexo核心，他的主要作用如下:<ol><li>实现了hexo功能<a href="https://github.com/hexojs/hexo/blob/master/lib/hexo/index.js#L59">扩展对象</a></li><li>实现了hexo核心功能, 如new, publish, generate等（其实是一些hexo插件，下文中会详细分析）</li></ol></li><li><strong>hexo plugins</strong>: 指一些能够扩展hexo的插件。插件可以按功能分成两类:<ol><li>扩展hexo命令的参数，如<a href="https://github.com/hexojs/hexo-server">hexo-server</a>(安装这个插件以后才能使用hexo server命令)</li><li>扩展hexo解析文件的”能力”，如增加jade模版解析功能的<a href="https://github.com/hexojs/hexo-renderer-jade">hexo-render-jade</a>插件</li></ol></li></ul><h2 id="从markdown到html的旅程"><a href="#从markdown到html的旅程" class="headerlink" title="从markdown到html的旅程"></a>从markdown到html的旅程</h2><p>简单来说，hexo中，从markdown到html的generate过程中做了两件事：</p><ol><li>模板渲染</li><li>模板渲染</li></ol><p>是的，就是这样，就是两次模板渲染。只不过两次渲染的输入、渲染模板的引擎、输出不一样。此处应该有一个表格：</p><img src="/images/howhexoworks/render.png" class=""><p>还得有一张图:</p><img src="/images/howhexoworks/post.png" class=""><blockquote><p>对上面表格和图的说明:</p><ul><li>hexo core在generate的过程中会产生一个对象，我们在这里把这个对象称为article。第一次渲染的主要目的就是给这个对象添加title,content等属性。其中:<ol><li>article.title, article.date, article.tags, article.categories等属性来自yml front的部分</li><li>article.content是markdown文章解析后的html片段</li></ol></li><li>hexo项目目录下包含三个子目录，<ol><li>source目录，写博客的主要工作目录。这个目录下存放的是我们的markdown文章以及js, images, css</li><li>themes目录，主题目录，定义了即将生成的html的layout, 和html中需要加载的css, js, images</li><li>public目录, hexo generate的最终输出目录。里面包含了整个博客网站的html, css, js, images</li></ol></li><li>第二次渲染，需要引入对应模板文件格式的插件，如.ejs文件就需要使用hexo-render-ejs插件，.jade文件需要使用hexo-render-jade插件，而.sass文件则需要hexo-render-sass插件来转换成css文件。hexo的这一设计有点类似webpack中的loader。</li></ul></blockquote><h2 id="hexo插件是如何工作的"><a href="#hexo插件是如何工作的" class="headerlink" title="hexo插件是如何工作的"></a>hexo插件是如何工作的</h2><p>hexo和webpack还有一点类似的地方就是插件驱动理念。即hexo(和webpack)是先实现一套(插件)扩展系统，然后再往扩展系统中添加插件来实现自身的功能。即我们日常使用的hexo init, hexo new，hexo generate等等功能都是通过一个个插件(其实就是一个个function)实现的。</p><blockquote><p>具体来讲就是:</p><ol><li><a href="https://github.com/hexojs/hexo/blob/master/lib/hexo/index.js#L59">hexo.extend</a>这个对象的每个属性都是一个用来绑定(特定)插件的对象。（所谓”绑定”，其实就是对象的register方法）</li><li>hexo<a href="https://github.com/hexojs/hexo/blob/master/lib/hexo/index.js#L153">初始化</a>过程中先加载内部插件，再加载外部插件</li></ol><p>而这些插件的功能分为两大类: 命令行插件和generate过程相关功能，例如：</p><ul><li>命令行插件, hexo <a href="https://github.com/hexojs/hexo/blob/master/lib/plugins/console/index.js#L47">new</a>, 是在hexo.extend.console对象上绑定的一个<a href="https://github.com/hexojs/hexo/blob/master/lib/plugins/console/new.js">插件</a></li><li>generate过程相关的插件，如上文提到的往article对象添加title,content等属性的功能，是通过往hexo.extend.processer对象上<a href="https://github.com/hexojs/hexo/blob/master/lib/plugins/processor/index.js#L13">绑定</a>post插件来<a href="https://github.com/hexojs/hexo/blob/master/lib/plugins/processor/post.js#L52">实现</a>的</li></ul><p>所以，当我们想自己动手写插件时，就是像hexo官网给出的<a href="https://hexo.io/api/console.html">这样</a>,调用某个对象的register方法，如hexo.extend.console.register。</p></blockquote><h2 id="hexo和git-page"><a href="#hexo和git-page" class="headerlink" title="hexo和git page"></a>hexo和git page</h2><img src="/images/howhexoworks/deploy.png" class=""><p>如上图，(用户通过浏览器访问到的)git page上的博客网站其实是hexo generate之后生成的public目录下的内容。</p><blockquote><p>所以，一个hexo博客项目应该有两个仓库:</p><ol><li>(基于hexo init结果的)<a href="https://github.com/buildAll/blogsrc">博客编写仓库</a>。可以把这个项目看成一个代码库，用来”开发”博客网站(包含写博客，生成博客等任务)</li><li>存放(hexo generate结果的)<a href="https://github.com/buildAll/buildall.github.io">public目录仓库</a>。这个项目是”只读”的，我们不会直接修改这个仓库的内容，我们也不会对这个仓库直接进行git pull、git commit、git push等常规操作。这个仓库的内容就是public目下的内容，即是通过hexo generate产生、hexo deploy提交的。</li></ol></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>hexo简洁、强大的功能来自于自身优雅的系统设计:</p><ol><li>hexo进程启动、hexo核心对象封装、插件系统分别独立</li><li>自身采用插件驱动，生来就具备高可扩展性</li></ol><p>希望读完这篇文章你能对hexo本身有更深入的理解，也能通过hexo的代码设计，对自己以后写出更优雅的代码有所启发。</p><p>对于本文或者hexo有任何问题或评论，请到<a href="https://github.com/buildAll/buildall.github.io/issues/3">这个</a>git issue页面给我留言吧。</p><script>console.log('hello, how are you?')</script>]]></content>
      
      
      <categories>
          
          <category> HowItWorks </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用standard来管理JavaScript代码规范</title>
      <link href="/2017/08/12/js-standard/"/>
      <url>/2017/08/12/js-standard/</url>
      
        <content type="html"><![CDATA[<img src="/images/jsstandard/standard_logo.png" class=""><p>怎么才能使前端团队写的JavaScript代码都有统一的风格、符合规范呢?</p><p>要解决这个问题大概要做下面几件事:</p><ol><li>制定规范标准</li><li>写代码时执行代码规范</li><li>检查代码是否符合规范</li><li>修改不符合规范的代码</li></ol><p>那么，到底具体应该如何实施以上几个步骤呢？我的回答是你什么都不用做了，有人已经帮你把以上四步全部做好了！</p><p>是的，这个好用的工具就是本文要介绍的JavaScript规范库，<a href="https://github.com/standard/standard">standarad</a>。</p><h2 id="关于standard"><a href="#关于standard" class="headerlink" title="关于standard"></a>关于standard</h2><h4 id="standard是什么"><a href="#standard是什么" class="headerlink" title="standard是什么?"></a>standard是什么?</h4><p>一个开源的JS代码规范库，它做了以下事情</p><ol><li>制定了所谓standard(标准)的JS代码规范</li><li>配合编辑器插件可以实时检查代码规范以及语法错误</li><li>通过执行命令检查代码规范以及语法错误</li><li>自动修复(可以直接修复的)不合规范的代码,使其符合规范</li></ol><h2 id="关于standard中的代码规范"><a href="#关于standard中的代码规范" class="headerlink" title="关于standard中的代码规范"></a>关于standard中的代码规范</h2><p>  可以说JS这门语言的魅力之一就是自由、开放的写法，相比python、Go等语言，JS写起来自由的多。但是这种自由本身在团队合作的项目里也带来了很多的不便，于是我们需要指定代码规范，但是应该以什么标准来制定规范呢？缩进到底是4格还是2格、结尾要不要用分号、花括号和if语句在同一行还是另起一行？诸如此类的问题，从功能和逻辑上来讲并没有标准答案，因为无论怎么选，代码都能运行，功能都能实现。所以在JS程序员的世界里经常会有诸如缩进、分号、换行等写法的争论，standard库对此给出的结论是，这种争论对于getting stuff done并无意义，我们要停止这方面的争论，把精力放在解决问题上。</p><p>  standard官方给出的说法如下:</p><p><em>There are lots of debates online about tabs vs. spaces, etc. that will never be resolved. These debates just distract from getting stuff done. At the end of the day you have to ‘just pick something’, and that’s the whole philosophy of standard – its a bunch of sensible ‘just pick something’ opinions. Hopefully, users see the value in that over defending their own opinions.</em></p><h2 id="使用standard"><a href="#使用standard" class="headerlink" title="使用standard"></a>使用standard</h2><p>好了，开始使用standard吧。</p><ol><li><p>新建一个项目</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> my-project</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> my-project</span></span><br></pre></td></tr></table></figure></li><li><p>安装standard</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm init</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install standard --save-dev</span></span><br></pre></td></tr></table></figure></li><li><p>安装snazzy，让代码检查的结果输出更加美观</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install snazzy --save-dev</span></span><br></pre></td></tr></table></figure></li><li><p>配置package.json, 添加一条名为lint的npm script</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line"> <span class="string">&quot;lint&quot;</span>: <span class="string">&quot;standard --verbose | snazzy&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在项目下新建一个app.js文件,随意输入一些代码并保存</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js             // 错误说明</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;          <span class="comment">// 结尾不应该有分号，而且a定义了没有使用</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; &#123;&#125;    <span class="comment">// f定义了但是没有使用</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">log</span>()                 <span class="comment">// log未定义</span></span><br></pre></td></tr></table></figure></li><li><p>运行代码检查</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">npm run lint</span></span><br></pre></td></tr></table></figure></li><li><p>看到检查结果</p></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1:7   error  &#x27;a&#x27; is assigned a value but never used  no-unused-vars</span><br><span class="line">1:12  error  Extra semicolon                         semi</span><br><span class="line">2:7   error  &#x27;f&#x27; is assigned a value but never used  no-unused-vars</span><br><span class="line">4:1   error  &#x27;log&#x27; is not defined                    no-undef</span><br></pre></td></tr></table></figure><h2 id="standard的更多功能"><a href="#standard的更多功能" class="headerlink" title="standard的更多功能"></a>standard的更多功能</h2><ol><li>使用<a href="https://github.com/standard/standard#are-there-text-editor-plugins">编辑器插件</a>，实时检查代码规范</li><li><a href="https://github.com/standard/standard#how-do-i-ignore-files">忽略</a>某些不需要执行代码规范的文件</li><li><a href="https://github.com/standard/standard#how-do-i-hide-a-certain-warning">局部禁用</a>代码检查</li><li><a href="https://github.com/standard/standard#i-use-a-library-that-pollutes-the-global-namespace-how-do-i-prevent-variable-is-not-defined-errors">指定全局变量</a>，以避免变量未定义错误</li><li><a href="https://github.com/standard/standard#is-there-a-git-pre-commit-hook">git pre-commit</a>钩子，在每次commit之前检查代码规范</li><li><a href="https://github.com/standard/standard#how-do-i-use-experimental-javascript-es-next-features">为更多最新的JS语法添加检查规范</a></li><li><a href="https://github.com/standard/standard#is-there-an-automatic-formatter">自动修复</a></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>standard应该是当前最好用的JS代码规范库，它无须更多配置，基本做到了安装即用，而且还有很多扩展功能，应该能够满足大多数项目的代码检查需求。</p><p>关于standard，如果你有任何问题可以来<a href="https://github.com/buildAll/buildall.github.io/issues/2">这里</a>一起讨论。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> standard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域和闭包--读《你不知道的JavaScript》</title>
      <link href="/2016/04/26/scopeandclosure/"/>
      <url>/2016/04/26/scopeandclosure/</url>
      
        <content type="html"><![CDATA[<img src="/images/javascript_logo/js.jpg" class=""><p>本文是在看完《你不知道的JavaScript》这本书之后整理而成。<br>本文中所有的代码可以在<a href="https://github.com/buildAll/JavaScript_Scope-Closure">这里</a>找到。如果你不想读下面的文字，可以直接clone代码并运行，然后结合代码和注释，试着去理解作用域和闭包的概念。</p><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>JavaScript采用词法作用域。所谓词法作用域就是代码书写完成之后，作用域随即确定，所写既所得。</p><p>看下面的代码;</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> printSpace = <span class="built_in">require</span>(<span class="string">&#x27;./printspace&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> showmore = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yoho = <span class="string">&quot;yoho!我在全局作用域&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">awfulSayYoho</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;*****一般情况*****&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(yoho);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">normalSayYoho</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;*****局部变量*****&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> yoho = <span class="string">&quot;yoho!我在函数作用域&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(yoho);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">advanceSayYoho</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// var yoho;   // B行, 自动提升声明</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;*****自动提升*****&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(yoho); <span class="comment">// C行，打印的是B行的声明，既undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (showmore) &#123;</span><br><span class="line">    <span class="keyword">var</span> yoho = <span class="string">&quot;yoho!我在函数作用域&quot;</span>; <span class="comment">// A行，声明yoho，并为其赋值。</span></span><br><span class="line">    <span class="comment">// yoho = &quot;yoho!我在函数作用域&quot;; 执行语句不提升，留在原地</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">sayYohoAgain</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(yoho);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">sayYohoAgain</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printSpace</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">awfulSayYoho</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">printSpace</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">normalSayYoho</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">printSpace</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">advanceSayYoho</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">printSpace</span>();</span><br></pre></td></tr></table></figure><p>上面这些代码的运行结果如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*****一般情况*****</span><br><span class="line">yoho!我在全局作用域</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*****局部变量*****</span><br><span class="line">yoho!我在函数作用域</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*****自动提升*****</span><br><span class="line">undefined</span><br><span class="line">yoho!我在函数作用域</span><br></pre></td></tr></table></figure><p>上面这段平淡无奇的代码，相信大多数JSer理解起来并不难。值得一提的是声明的自动提升。在advanceSayYoho函数里的A行，声明了变量yoho并为其赋值，既看上去一行代码做了两件事:声明且赋值。但是，在函数被调用时，JS引擎总是将A行这样的”声明且赋值”的语句拆分成声明和赋值两步执行，既</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  yoho = <span class="string">&quot;yoho!我在函数作用域&quot;</span>;</span><br></pre></td></tr></table></figure><p>被分成了：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> yoho;</span><br><span class="line">yoho = <span class="string">&quot;yoho!我在函数作用域&quot;</span>;</span><br></pre></td></tr></table></figure><p>其中声明语句</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> yoho;</span><br></pre></td></tr></table></figure><p>这行被自动提升到函数体的顶部，既相当于自动提升到了advanceSayYoho函数的B行。</p><p>而赋值语句</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yoho = <span class="string">&quot;yoho!我在函数作用域&quot;</span>;</span><br></pre></td></tr></table></figure><p>不会提升，留在原地</p><p>由此便不难理解为什么C行打印的是undefined了。</p><h2 id="原始数据类型和引用数据类型"><a href="#原始数据类型和引用数据类型" class="headerlink" title="原始数据类型和引用数据类型"></a>原始数据类型和引用数据类型</h2><p>在进一步讨论作用域及作用域对象的之前，先简单的说明一下JS里的“赋值”和”引用”。</p><p>JS里有两大类数据类型: 原始数据类型和引用数据类型（及对象数据类型）。下面的代码试图说明这两者的区别:</p><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> printSpace = require(&#x27;./printspace&#x27;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值传递</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">&quot;*****值传递*****&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = 10; <span class="comment">// num 持有了数字10</span></span><br><span class="line"><span class="keyword">var</span> a = num;  <span class="comment">//   a 持有了数字10</span></span><br><span class="line"><span class="keyword">var</span> b = num;  <span class="comment">//   b 持有了数字10</span></span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">&quot;------初始-----&quot;</span>);</span><br><span class="line">console.<span class="built_in">log</span>(num);</span><br><span class="line">console.<span class="built_in">log</span>(a);</span><br><span class="line">console.<span class="built_in">log</span>(b);</span><br><span class="line"></span><br><span class="line">num = 8; <span class="comment">// num 持有的数字变为了8</span></span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">&quot;------num值改变后-----&quot;</span>);</span><br><span class="line">console.<span class="built_in">log</span>(num);</span><br><span class="line">console.<span class="built_in">log</span>(a);</span><br><span class="line">console.<span class="built_in">log</span>(b);</span><br><span class="line"></span><br><span class="line">printSpace();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的引用</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">&quot;*****对象的引用*****&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yoho = &#123;     <span class="comment">// yoho 引用了对象 &#123;value: “潮流”&#125;</span></span><br><span class="line">  value: <span class="string">&quot;潮流&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kris = yoho; <span class="comment">// kris 引用了对象 &#123;value: “潮流”&#125;</span></span><br><span class="line"><span class="keyword">var</span> me = yoho;   <span class="comment">// me 引用了对象 &#123;value: “潮流”&#125;</span></span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">&quot;------初始----&quot;</span>);</span><br><span class="line">console.<span class="built_in">log</span>(yoho.value);</span><br><span class="line">console.<span class="built_in">log</span>(kris.value);</span><br><span class="line">console.<span class="built_in">log</span>(me.value);</span><br><span class="line"></span><br><span class="line">me.value = <span class="string">&quot;还是潮流&quot;</span>; <span class="comment">// A行， &quot;被me 引用的对象&quot;.value 发生了</span></span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">&quot;------me.value改变后-----&quot;</span>);</span><br><span class="line">console.<span class="built_in">log</span>(yoho.value);</span><br><span class="line">console.<span class="built_in">log</span>(kris.value);</span><br><span class="line">console.<span class="built_in">log</span>(me.value);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行node reference，可以看到:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*****值传递*****</span><br><span class="line">------初始-----</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">------num值改变后-----</span><br><span class="line">8</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*****对象的引用*****</span><br><span class="line">------初始----</span><br><span class="line">潮流</span><br><span class="line">潮流</span><br><span class="line">潮流</span><br><span class="line">------me.value改变后-----</span><br><span class="line">还是潮流</span><br><span class="line">还是潮流</span><br><span class="line">还是潮流</span><br></pre></td></tr></table></figure><p>可能有些新JSer不太能理解的是：上面代码的A行只修改了me.value的值，为什么yoho.value和kris.value也发生了变化？</p><p>其实上面代码中，yoho、me、kris这三个变量是等同的，他们都指向同一块内存空间，既对象 { value: “潮流” }所在的内存空间。也就是yoho、me、kris三个变量同时引用了对象{ value: “潮流” }。</p><p>所以me.value、kris.value、yoho.value都是同一块内存空间，而那块内存里的值一开始的值是“潮流”, 然后在A行，这个值被改为了”还是潮流”。</p><p>如果还是不能理解”引用”这个概念，建议可以去看看C语言里指针的概念。</p><h2 id="变量的生命周期、作用域对象及作用域链"><a href="#变量的生命周期、作用域对象及作用域链" class="headerlink" title="变量的生命周期、作用域对象及作用域链"></a>变量的生命周期、作用域对象及作用域链</h2><p>请看下面的代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JS代码由此开始运行，创建了 globalScope = &#123;&#125;</span></span><br><span class="line"><span class="comment">// 紧接着JS引擎对整个代码内容进行检查，搜索出全局变量，并将他们的声明设置为globalScope的属性</span></span><br><span class="line"><span class="comment">// 既 globalScope = &#123;</span></span><br><span class="line"><span class="comment">//     yohobuy: yohobuy,</span></span><br><span class="line"><span class="comment">//     PRINTSPACE: PRINTSPACE,</span></span><br><span class="line"><span class="comment">//     sayYoho: sayYoho</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// globalScope.PRINTSPACE = require(&#x27;./printspace&#x27;);</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">PRINTSPACE</span> = <span class="built_in">require</span>(<span class="string">&#x27;./printspace&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// globalScope.yohobuy = &quot;YOHO!buy&quot;;</span></span><br><span class="line"><span class="keyword">var</span> yohobuy = <span class="string">&quot;YOHO!buy&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// globalScope.sayYoho = function() &#123;......&#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayYoho</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 函数开始执行，创建了scope = &#123;&#125;</span></span><br><span class="line">  <span class="comment">// 设置scope chain, 既 scope.parentScope = globalScope</span></span><br><span class="line">  <span class="comment">// 提升开始: scope.yoho = undefined;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> yoho = <span class="string">&quot;yoho!&quot;</span>; <span class="comment">// scope.yoho = &quot;yoho&quot; ， 此时scope = &#123;yoho: &quot;yoho&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(yoho);  <span class="comment">// 打印的是scope.yoho</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(yohobuy); <span class="comment">//打印的是scope.parentScope.yohobuy, 既scope.globalScope.yohobuy</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">PRINTSPACE</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayYoho</span>();</span><br><span class="line"><span class="comment">// 函数调用完成，在函数调用过程中创建的scope对象此时没有被任何人引用，那么这个scope对象被自动回收</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">PRINTSPACE</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(yoho); <span class="comment">// 打印的是globalScope.yoho, 而globalScope上并没有定义yoho属性</span></span><br></pre></td></tr></table></figure><p>运行结果如你所料:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yoho!</span><br><span class="line">YOHO!buy</span><br><span class="line"></span><br><span class="line">/Users/bill/Documents/Work/closure/lifecycle.js:36</span><br><span class="line">console.log(yoho); // 打印的是globalScope.yoho, 而globalScope上并没有定义yoho属性</span><br><span class="line"></span><br><span class="line">ReferenceError: yoho is not defined</span><br><span class="line">    at Object.&lt;anonymous&gt; (/Users/bill/Documents/Work/closure/lifecycle.js:36:13)</span><br><span class="line">    at Module._compile (module.js:413:34)</span><br><span class="line">    at Object.Module._extensions..js (module.js:422:10)</span><br><span class="line">    at Module.load (module.js:357:32)</span><br><span class="line">    at Function.Module._load (module.js:314:12)</span><br><span class="line">    at Function.Module.runMain (module.js:447:10)</span><br><span class="line">    at startup (node.js:140:18)</span><br><span class="line">    at node.js:1001:3</span><br></pre></td></tr></table></figure><p>依然是一段有些无聊的代码，但愿你看到他们的时候不要打呵欠或是关掉这个网页:)))让我们来看看这里发生的一些有趣的事情:</p><ol><li>JS代码只要被运行，便会在一开始的时候就创建一个全局的作用域对象，在这里为了方便起见，我把它称为globalScope。</li><li>globalScope对象创建完成后，立刻去全局范围内搜索全局变量，并将变量的名字设为自己属性名，同时引用相对应的变量。</li><li>sayYoho函数被调用时，创建了它自己的作用域对象，我把它称为scope。</li><li>scope对象会设置自己的父级作用域对象，既当前函数作用域的上一个作用域，在这里就是globalScope。</li><li>紧接着, scope对象开始在函数作用域内部搜索局部变量，并将其设置为自己的属性。值得一提的是，这步只完成了属性名的设置，并未对属性赋值。(这一步既是上文提到的所谓变量的提升)</li><li>函数运行结束后，如果(通常就是这样)scope对象没有被引用，则其会被JS引擎回收。*(反之，如果函数运行结束后，还有变量在引用scope对象，则该对象不会被回收)*</li></ol><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>很高兴你能看到这里。我们终于来到了闭包的概念。可是别激动，我还是只能提供一段最稀松平常的闭包代码，你一定看过类似下面这样的代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处有globalScope 对象； .... 不再赘述</span></span><br><span class="line"><span class="keyword">var</span> printSpace = <span class="built_in">require</span>(<span class="string">&#x27;./printspace&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 函数被调用时，产生了新的outerScope对象, 既outerScope = &#123;&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 设置scope chain，既 outerScope.parentScope = globalScope;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 提升开始： outerScope.counter = undefined;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// outerScope.counter = 0;</span></span><br><span class="line">  <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 函数被调用的话，产生新的insideScope = &#123;&#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 设置scope chain，既 insideScope.parentScope = outerScope;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 此时完整的scope chain 可以想成这样的 insideScope.parentScope.parentScope</span></span><br><span class="line">    <span class="comment">// 既 insideScope.outerScope.globalScope</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 函数内部没有 var 定义的变量，所以insideScope没有变化</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(counter); <span class="comment">// 此处需要打印的是 insideScope.outerScope.counter。既outerScope对象被引用了！！</span></span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> insideFunc = <span class="title function_">outerFunc</span>(); <span class="comment">// 因为outerFunc的调用，内部函数被return出来</span></span><br><span class="line">                              <span class="comment">// return 出来的内部函数被insideFunc引用</span></span><br><span class="line">                              <span class="comment">// 由于insideFunc 引用的函数内部引用了 outerScope上的属性counter,</span></span><br><span class="line">                              <span class="comment">// 所以outerScope对象不会被回收，从效果上来讲就是局部变量counter一直存活了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 不妨假想成下面的代码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * var insideFunc = function() &#123;</span></span><br><span class="line"><span class="comment"> *   console.log(counter);</span></span><br><span class="line"><span class="comment"> *   counter += 1;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 其中的counter变量来自outerFunc被调用时所创建的作用域对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">printSpace</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">insideFunc</span>();</span><br><span class="line"><span class="title function_">insideFunc</span>();</span><br><span class="line"><span class="title function_">insideFunc</span>();</span><br><span class="line"><span class="title function_">insideFunc</span>();</span><br><span class="line"><span class="title function_">insideFunc</span>();</span><br><span class="line"><span class="title function_">insideFunc</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">printSpace</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherInsideFunc = <span class="title function_">outerFunc</span>(); <span class="comment">//A行， outerFunc又被调用一次，产生了新的scope chain</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">anotherInsideFunc</span>();</span><br><span class="line"><span class="title function_">anotherInsideFunc</span>();</span><br><span class="line"><span class="title function_">anotherInsideFunc</span>();</span><br><span class="line"><span class="title function_">anotherInsideFunc</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">printSpace</span>();</span><br></pre></td></tr></table></figure><p>运行一下node closure，看到下面的结果：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>从结果上来讲，这段代码只是达到了将counter这个一般情况下会随着函数运行结束而被销毁的局部变量保留住了的效果。到底是怎么做到这点的呢，简单来说，过程是这样的:</p><ol><li>outerFunc被调用时创造了作用域对象，outerScope，以及由这个outerScope对象做为起点的一条作用域链</li><li>outerFunc运行到最后时return了一个匿名函数, 而这个匿名函数使用(既引用)了outerScope对象上的属性counter。</li><li>此时如果没有其他变量引用return的匿名函数，那么将不会有特别的事情发生，outerScope对象会被回收。</li><li>但是，被return的匿名函数又被innerFunc这个变量引用，所以为了保证其在随后的代码中能被顺利被执行，必须让innerFunc引用的函数内的所有变量都有意义，既counter必须被保留，所以相当于outerScope对象被引用了, 那么outerScope就不会被释放。</li><li>A行中，outerFunc又被调用了一次，则其又产生了一个新的outerScope对象，所以后面anotherInsideFunc执行时，counter又从0开始。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了理解闭包，需要想通下面几点:</p><ol><li>函数运行时会创建作用域对象及以此对象为起点的作用域链。</li><li>借由函数一等公民的身份，JS函数内部的函数可以被传递给别的变量，既内部函数可以被引用。</li><li>一旦内部函数被引用，并且该内部函数使用了自身作用域链上某个父级作用域对象上的属性，那么该父级作用域对象即使在外部函数运行结束后扔不会被回收。</li><li>外部函数每被调用一次，都会创建新的作用域链。</li><li>作用域链是树形的，下面这张简陋的图也许可以帮助你理解这一概念。</li></ol><p><img src="https://raw.githubusercontent.com/buildAll/JavaScript_Scope-Closure/master/scopechain.png" alt="scope chain 示意图"></p><p>要产生闭包，关键就是:</p><ol><li>至少有一个外部函数，外部函数内至少有一个内部函数。</li><li>外部函数一定要运行至少一次，以此产生作用域对象并将内部函数传递给函数外部变量。</li></ol><h3 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h3><p>对本文有任何问题和建议可以在<a href="https://github.com/buildAll/JavaScript_Scope-Closure/issues/1">这里</a>一起讨论。</p><h3 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL; DR;"></a>TL; DR;</h3><p>按照《JavaScript权威指南》里的说法，闭包并不是JS特有的，它是一种计算机术语，在计算机科学中，将函数和作用域联系起来的这种机制就是闭包，所以理论上所有的JS函数都可以被认为是闭包。但是我们平时说的闭包，更多的是指的外部函数运行时产生的作用域对象被保留的现象。</p><p>《你不知道的JavaScript》这本书在github上有英文的<a href="https://github.com/getify/You-Dont-Know-JS">开源版本</a>，任何人都可以为其贡献内容，该项目已经有接近30000star。目前其中的部分章节被翻译并出版成纸质书籍，感兴趣的话可以<a href="http://www.amazon.cn/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript-%E7%BE%8E-%E8%BE%9B%E6%99%AE%E6%A3%AE/dp/B0153179VI?ie=UTF8&keywords=%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript&qid=1461847068&ref_=sr_1_1&sr=8-1">去看看</a>。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现在开始用vim开发Web前端吧</title>
      <link href="/2015/12/09/frontendvim/"/>
      <url>/2015/12/09/frontendvim/</url>
      
        <content type="html"><![CDATA[<img src="/images/vim-logo.png" class=""><p>如果你是一名web前端工程师并且没有vim使用经验的话，那么这篇博文就是为你准备的。</p><h2 id="vim是什么"><a href="#vim是什么" class="headerlink" title="vim是什么"></a>vim是什么</h2><p>vim是一款文本编辑器应用程序。和一般的编辑器程序不同，vim有以下特点:</p><ol><li>运行在终端,而非桌面</li><li>不需要使用鼠标进行操作，所有操作都通过键盘实现</li><li>Linux系统默认安装这款编辑器</li></ol><h2 id="为什么用vim"><a href="#为什么用vim" class="headerlink" title="为什么用vim"></a>为什么用vim</h2><p>前端最流行的编辑器应该是sublime text和web storm，这两个应用程序确实也非常好用，能有效的提高前端的开发效率。那为什么我们还要使用vim来做前端开发呢，原因如下:</p><ol><li>vim的命令系统使得开发者可以在编码过程中无需操作鼠标，两只手可以全程专注在敲击键盘上，这样无论对于提升开发效率还是开发者编码的体验都会有帮助。</li><li>vim界面十分简洁，并且能够自由、灵活的打开、切换多窗口。</li><li>vim和sublime一样，有着强大的插件系统，类似zen coding，多行编辑，语法检查等功能都可以在vim上实现</li><li>Web前端开发人员难免需要上服务器查看或修改代码，而所有的Linux服务器上都自带vim，此时如果这名前端会使用vim的话必然对工作有很大帮助。</li></ol><h2 id="vim相关的概念"><a href="#vim相关的概念" class="headerlink" title="vim相关的概念"></a>vim相关的概念</h2><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>vim中的操作都是通过命令来实现的，比如移动光标、复制、粘贴等，都有对应的命令。<br>下文会介绍一些常用的命令。</p><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>vim的部分命令有对应的模式，如果要使用这些命令，首先要进入命令所属的模式。</p><p>各个模式的关系如下:</p><!--<img src="images/frontendvim/vim-mode.jpg" alt="vim中的模式">--><img src="/images/frontendvim/vim-mode.jpg" class=""><p>对上图的解释</p><ol><li>默认模式处于最顶层，在任意模式下，按ESC进入默认模式</li><li>VISUAL, VISUAL BLOCK和命令行模式之间可以通过命令互相切换</li></ol><h2 id="安装vim"><a href="#安装vim" class="headerlink" title="安装vim"></a>安装vim</h2><p>心动不如行动，先安装vim吧。对于安装，网上有很多教程，如：</p><p><a href="http://linux.chinaunix.net/techdoc/install/2009/04/20/1108200.shtml">Windows中的vim安装教程</a></p><p><a href="http://www.cnblogs.com/lwbqqyumidi/archive/2012/08/22/2651337.html">Linux中的vim安装教程</a></p><h2 id="vim插件管理工具"><a href="#vim插件管理工具" class="headerlink" title="vim插件管理工具"></a>vim插件管理工具</h2><p>上面提到vim有很多插件，所以我们需要一个插件管理工具，我平时使用的是<a href="https://github.com/tpope/vim-pathogen">vim-pathogen</a>, 用了这个工具后，就可以轻松的安装各种插件了。</p><p>pathogen安装插件的通用步骤:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/.vim/bundle/</span><br><span class="line">sudo git clone &lt;所要安装插件的github代码库url&gt;</span><br></pre></td></tr></table></figure><p>删除插件的方法:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/.vim/bundle/</span><br><span class="line">sudo rm -rf &lt;需要删除的插件文件夹&gt;</span><br><span class="line">或</span><br><span class="line">sudo rm &lt;需要删除的插件文件名&gt;</span><br></pre></td></tr></table></figure><p>就是这么简单。</p><h2 id="vim配置文件-vimrc"><a href="#vim配置文件-vimrc" class="headerlink" title="vim配置文件.vimrc"></a>vim配置文件.vimrc</h2><p>vim本身有一些配置项目，这些配置都写在~&#x2F;.vimrc这个文件里，通过<span style="background-color:#d0d0d0">vim ~&#x2F;.vimrc</span>可以查看或者编辑这个文件。</p><h2 id="前端常用插件"><a href="#前端常用插件" class="headerlink" title="前端常用插件"></a>前端常用插件</h2><p>以下是我平时前端开发中用到的插件：<br><a href="https://github.com/scrooloose/nerdtree">NerdTree</a>。必装插件，实现树状文件查找。<br><a href="https://github.com/Valloric/YouCompleteMe">YouCompleteMe</a>。必备插件，代码自动补齐。<br><a href="https://github.com/mattn/emmet-vim">emmet-vim</a>。必备插件，zen-coding。<br><a href="https://github.com/terryma/vim-multiple-cursors">vim-multiple-cursors</a>。同时多行编辑。<br><a href="https://github.com/Yggdroot/indentLine">indentLine</a>。显示代码缩进。<br><a href="https://github.com/scrooloose/syntastic">syntastic</a>。语法检查。<br><a href="https://github.com/othree/javascript-libraries-syntax.vim">javascript-libraries-syntax.vim</a>。JS代码高亮插件。<br><a href="https://github.com/jelera/vim-javascript-syntax">vim-javascript-syntax</a>。代码折叠。<br><a href="https://github.com/ternjs/tern_for_vim">tern_for_vim</a>。快速跳转到变量&#x2F;函数定义的地方。<br><a href="https://github.com/vim-scripts/JavaScript-Indent">JavaScript-Indent</a>。代码缩进。</p><h2 id="开始使用vim"><a href="#开始使用vim" class="headerlink" title="开始使用vim"></a>开始使用vim</h2><p>在命令行中通过输入<span style="background-color:#d0d0d0">vim  &lt;文件名&gt; </span>开始编辑文件。 如要打开index.html，则输入 <span style="background-color:#d0d0d0">vim index.html </span>。</p><p>vim打开文件后，不要急着按键，或者试图通过鼠标来做任何操作，所有的操作都是通过键盘输入来实现的。</p><h3 id="以下所有命令如无特殊说明，都是按顺序输入，-如要输入命令-ctrl-w-l-则先按ctrl-然后松开ctrl，再按w，再松开w，再按l，再松开l。其中任何一个按键都不可以按住不放，整个输入过程自然连贯即可。"><a href="#以下所有命令如无特殊说明，都是按顺序输入，-如要输入命令-ctrl-w-l-则先按ctrl-然后松开ctrl，再按w，再松开w，再按l，再松开l。其中任何一个按键都不可以按住不放，整个输入过程自然连贯即可。" class="headerlink" title="以下所有命令如无特殊说明，都是按顺序输入， 如要输入命令 ctrl w l, 则先按ctrl, 然后松开ctrl，再按w，再松开w，再按l，再松开l。其中任何一个按键都不可以按住不放，整个输入过程自然连贯即可。"></a><em>以下所有命令如无特殊说明，都是按顺序输入， 如要输入命令 ctrl w l, 则先按ctrl, 然后松开ctrl，再按w，再松开w，再按l，再松开l。其中任何一个按键都不可以按住不放，整个输入过程自然连贯即可。</em></h3><h3 id="vim中的命令都是大小写敏感的，所以需要注意各个命令的大小写。"><a href="#vim中的命令都是大小写敏感的，所以需要注意各个命令的大小写。" class="headerlink" title="vim中的命令都是大小写敏感的，所以需要注意各个命令的大小写。"></a><em>vim中的命令都是大小写敏感的，所以需要注意各个命令的大小写。</em></h3><h3 id="默认模式"><a href="#默认模式" class="headerlink" title="默认模式"></a>默认模式</h3><p>vim打开文件后默认直接进入该模式。</p><p>进入默认模式的命令: ESC</p><h4 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h4><p>vim中光标的的移动是通过按键实现的。</p><h4 id="一般的移动："><a href="#一般的移动：" class="headerlink" title="一般的移动："></a>一般的移动：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">上移光标 k</span><br><span class="line">下移光标 j</span><br><span class="line">左移光标 h</span><br><span class="line">右移光标 l</span><br></pre></td></tr></table></figure><h4 id="快速移动："><a href="#快速移动：" class="headerlink" title="快速移动："></a>快速移动：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">直接移动到当前所在行的头部 0 (数字零)</span><br><span class="line">直接移动到当前所在行的尾部 $</span><br><span class="line">光标跳转到目标行 数字 gg  ，如跳到第74行,则输入 74gg</span><br><span class="line">光标跳转到文件头部 gg</span><br><span class="line">光标跳转到文件尾部 G</span><br><span class="line">跳转到上一个编辑处 ctrl o</span><br><span class="line">跳转到下一个编辑处 ctrl i</span><br><span class="line"></span><br><span class="line">跳转到行内某个字母(行内查找)  f 所要查找的内容  ，如跳到当前光标所在行的a字母所在处: f a</span><br><span class="line">然后按;(分号)跳转到下一个a，按,(逗号)跳转到上一个a</span><br><span class="line"></span><br><span class="line">跳到下一个单词的开头 w</span><br><span class="line">跳到前一个单词的开头 b</span><br></pre></td></tr></table></figure><h4 id="窗口大小调整命令-只在打开多个窗口时生效"><a href="#窗口大小调整命令-只在打开多个窗口时生效" class="headerlink" title="窗口大小调整命令(只在打开多个窗口时生效)"></a>窗口大小调整命令(只在打开多个窗口时生效)</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">增加窗口宽度 ctrl w &gt; 或者ctrl w 数字 &gt; 。加入数字后可以快速增加宽度</span><br><span class="line">减小窗口宽度 ctrl w &lt; 或者ctrl w 数字 &lt; 。加入数字后可以快速减小宽度</span><br><span class="line">增加窗口高度 ctrl w + 或者ctrl w 数字 + 。加入数字后可以快速增加高度</span><br><span class="line">减小窗口高度 ctrl w - 或者ctrl w 数字 - 。加入数字后可以快速增加高度</span><br><span class="line"></span><br><span class="line">跳转到上窗口 ctrl w k</span><br><span class="line">跳转到下窗口 ctrl w j</span><br><span class="line">跳转到左窗口 ctrl w h</span><br><span class="line">跳转到右窗口 ctrl w l</span><br></pre></td></tr></table></figure><h4 id="普通命令"><a href="#普通命令" class="headerlink" title="普通命令"></a>普通命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">查找 / 需要查找的内容 回车</span><br><span class="line">例如要查找单词hello，则输入/hello ,再按回车键</span><br><span class="line"></span><br><span class="line">查找当前光标所在位置的单词 gd</span><br><span class="line"></span><br><span class="line">在查找到的结果中快速移动光标:</span><br><span class="line"></span><br><span class="line">上移 n</span><br><span class="line">下移 N</span><br><span class="line"></span><br><span class="line">取消查找内容高亮 :noh</span><br><span class="line"></span><br><span class="line">保存 :w</span><br><span class="line">退出 :q</span><br><span class="line">保存并退出 :wq</span><br><span class="line">强制退出 :q!</span><br><span class="line"></span><br><span class="line">复制当前光标所在行 yy</span><br><span class="line">剪切当前光标所在行 dd</span><br><span class="line">剪切多行 数字 dd （数字为需要剪切的行数）</span><br><span class="line">复制当前光标选中的字符 y</span><br><span class="line">剪切当前光标选中的字符 x</span><br><span class="line">剪并进入INSERT模式 s</span><br><span class="line"></span><br><span class="line">粘贴 p</span><br><span class="line">undo u</span><br><span class="line">re-undo ctrl r</span><br><span class="line"></span><br><span class="line">常规删除 &quot;_d</span><br><span class="line">常规复制 &quot;+y</span><br><span class="line">常规粘贴 command v(MAC OS) 或者 ctrl v(Windows系统)</span><br><span class="line"></span><br><span class="line">替换光标当前位置字符 r 然后输入要替换的字母。 例如，要替换&quot;hello world&quot;中的d为o，则先将光标移动到d，然后按r，然后再o</span><br></pre></td></tr></table></figure><p>需要解释的是:</p><ol><li>yy和y复制是指的yank，yank所复制的内容只能通过p粘贴，而上面的常规复制则可以将vim里的内容复制并通过ctrl&#x2F;command v 复制到别处。</li><li>vim里除了上面的常规删除以外并没有原生的快速删除的命令(不过，你可以自定义命令)，像x,dd等命令都是自带了yank。如你想删除”hello world”里的d，光标移到d，再按x，然后你再按p的话就粘贴了d。</li><li>常规删除的内容不可以通过p粘贴，只能通过常规粘贴命令进行粘贴。</li></ol><h3 id="INSERT模式"><a href="#INSERT模式" class="headerlink" title="INSERT模式"></a>INSERT模式</h3><p>以下任意命令都可以进入编辑模式。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">在光标当前位置输入 i</span><br><span class="line">在光标当前位置的下一格输入 a</span><br><span class="line">在光标当前位置所在行的开头开始输入 o</span><br><span class="line">在光标当前位置所在行的下一行开始输入 o</span><br><span class="line">在光标当前位置所在行的上一行开始输入 O</span><br></pre></td></tr></table></figure><p>进入编辑模式后，vim左下角出现 – INSERT –，此时可以像在普通编辑器里一样开始写代码了。因为键盘输入直接被写在了当前的文件里，所以vim命令此刻都“失效”了。</p><p>退出编辑模式的命令 ESC</p><h3 id="VISUAL模式"><a href="#VISUAL模式" class="headerlink" title="VISUAL模式"></a>VISUAL模式</h3><p>进入该模式的命令 v<br>退出该模式的命令 ESC<br>进入编辑模式后，vim左下角出现 – VISUAL –，一般在需要选择文本的时候进入这个模式。</p><p>在VISUAL模式下移动光标的命令和普通模式下是一样的，区别是光标移动时会选中移动路径上的文本。</p><p>选中后按y复制，按x或者d剪切，</p><p>VISUAL模式下一次性替换整块文本:</p><ol><li>选中并yank复制(按键y)马上要用来替换的内容</li><li>移动光标选中需要被替换的文本</li><li>ctrl r</li><li>p</li></ol><h3 id="VISUAL-BLOCK模式"><a href="#VISUAL-BLOCK模式" class="headerlink" title="VISUAL BLOCK模式"></a>VISUAL BLOCK模式</h3><p>进入该模式的命令 ctrl v<br>退出该模式的命令 ESC</p><p>该模式常常用于快速注释代码，步骤如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 光标移动到需要注释的代码的第一行的开头</span><br><span class="line">2. ctrl v</span><br><span class="line">3. j命令下移至需要注释代码的最后一行</span><br><span class="line">4. I</span><br><span class="line">5. 输入//</span><br><span class="line">6. ESC</span><br></pre></td></tr></table></figure><p>注意，第六步需要过n秒才会生效</p><p>快速缩进多行代码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 光标移动到需要缩进的代码的第一行的开头</span><br><span class="line">2. ctrl v</span><br><span class="line">3. j命令下移至需要缩进代码的最后一行</span><br><span class="line">4. I</span><br><span class="line">5. 按空格缩进代码</span><br><span class="line">6. ESC</span><br></pre></td></tr></table></figure><p>注意，第六步需要过n秒才会生效</p><h3 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h3><p>进入该模式的命令  :(冒号)<br>退出该模式的命令 ESC</p><p>该模式下常用的命令:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">在竖直方向打开新窗口 vsp <span class="tag">&lt;<span class="name">所要打开的文件路径</span>&gt;</span></span><br><span class="line">在水平方向打开新窗口 sp  <span class="tag">&lt;<span class="name">所要打开的文件路径</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="NerdTree"><a href="#NerdTree" class="headerlink" title="NerdTree"></a>NerdTree</h2><p>NerdTree的使用小窍门:</p><ol><li>o命令打开文件后可以 ctrl o回到NerdTree</li><li>t命令打开新tab后，可以按gt切换到下一个tab，按gT切换到前一个tab</li><li>VISUAL模式下按:(冒号)vsp 可以打开一个较窄的窗口，这样大小的窗口用来显示NerdTree比较合适。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>vim作为一款经典的老派编辑器能够存在这么多年，一定有它存在的理由。刚接触时可能会有一些不适应，但是如果能够坚持使用，其实并不需要多久，就能快速高效的使用vim编程了。希望本文能带你进入vim的世界。</p><p>关于vim，如果你有任何问题可以来<a href="https://github.com/buildAll/buildall.github.io/issues/1">这里</a>一起讨论。</p><script>    function removeImgBorder() {        var imgs = document.getElementsByTagName('img');        [].forEach.call(imgs, function(img, idx) {            img.parentNode.style.borderBottom = 'none';        });    }    window.onload = removeImgBorder;</script>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> front-end tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速上手require.js</title>
      <link href="/2015/11/23/requirebasic/"/>
      <url>/2015/11/23/requirebasic/</url>
      
        <content type="html"><![CDATA[<img src="/images/javascript_logo/js.jpg" class=""><h2 id="requirejs是什么"><a href="#requirejs是什么" class="headerlink" title="requirejs是什么"></a>requirejs是什么</h2><p>requriejs是一个js插件，这个插件可以在各种js运行环境里自动、异步加载js文件。<br>更多内容参考:<br><a href="http://requirejs.org/">requirejs官网</a><br><a href="https://github.com/jrburke/requirejs">requirejs的Git仓库</a></p><h2 id="关于本文的示例代码"><a href="#关于本文的示例代码" class="headerlink" title="关于本文的示例代码"></a>关于本文的示例代码</h2><p>本文中的所有代码都可以在<a href="https://github.com/buildAll/dead-basic-requirejs-demo">这里</a>看到或下载。</p><h2 id="为什么使用requirejs"><a href="#为什么使用requirejs" class="headerlink" title="为什么使用requirejs"></a>为什么使用requirejs</h2><p>前端js代码越来越多，如果使用模块化开发，可以降低代码藕合，提高代码的可维护性。而requirejs可以比较好的支持的js模块化开发思想。<br>不过requirejs并不是唯一支持js模块开发的插件，类似功能的插件还有<a href="http://browserify.org/">browserify</a>等。</p><h2 id="如何使用requirejs"><a href="#如何使用requirejs" class="headerlink" title="如何使用requirejs"></a>如何使用requirejs</h2><h3 id="下载requirejs"><a href="#下载requirejs" class="headerlink" title="下载requirejs"></a>下载requirejs</h3><p>打开<a href="http://requirejs.org/docs/release/2.1.22/comments/require.js">链接</a>，复制源码到你的文件里，保存为require.js。</p><h3 id="建立项目"><a href="#建立项目" class="headerlink" title="建立项目"></a>建立项目</h3><p>建立如下的目录结构:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">app/</span><br><span class="line">  index.html</span><br><span class="line">  js/</span><br><span class="line">    lib/</span><br><span class="line">       require.js   /*require.js源码*/</span><br><span class="line">       print.js     /*自定义的(库)模块*/</span><br><span class="line">    app/</span><br><span class="line">       app.js       /*放置应用main方法的文件，名字可以任意起*/</span><br><span class="line">       me.js        /*自定义的(应用级)模块，名字可以任意起*/</span><br><span class="line">    main.js         /*调用require方法的文件，既入口文件，名字可以任意起*/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="为页面引入requirejs"><a href="#为页面引入requirejs" class="headerlink" title="为页面引入requirejs"></a>为页面引入requirejs</h3><p>index.html代码如下:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>requirejs basic <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  src属性指向require.js</span></span><br><span class="line"><span class="comment">  data-main属性指向main.js，注意1：可以省略.js，注意2:该文件既为调用require方法的文件</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;js/lib/require.js&#x27;</span> <span class="attr">data-main</span>=<span class="string">&#x27;js/main&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的script里的写法是固定的，既设置src和data-main属性，分别找到require.js的源码和我们自己页面调用require方法的入口文件。</p><h3 id="配置及启动requirejs"><a href="#配置及启动requirejs" class="headerlink" title="配置及启动requirejs"></a>配置及启动requirejs</h3><p>打开main.js，输入以下代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.<span class="title function_">config</span>(&#123;</span><br><span class="line">  <span class="comment">//baseUrl为requirejs需要加载的模块的根目录，后面的模块路径都是相对于这个目录的</span></span><br><span class="line">  <span class="attr">baseUrl</span>: <span class="string">&#x27;./js&#x27;</span>,</span><br><span class="line">  <span class="attr">paths</span>: &#123;</span><br><span class="line">  <span class="comment">//模块名: .js文件相对于baseUrl的路径</span></span><br><span class="line">    <span class="attr">me</span>: <span class="string">&#x27;app/me&#x27;</span>,</span><br><span class="line">    <span class="attr">print</span>: <span class="string">&#x27;lib/print&#x27;</span>,</span><br><span class="line">    <span class="attr">myApp</span>: <span class="string">&#x27;app/app&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动myApp模块，既运行js/app/app.js</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;myApp&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>可以看到，首先调用了require.config()去进行一些配置，这里主要配置了baseUrl和paths。<br>baseUrl可以看成所有模块的根目录。<br>paths中定义了各个模块(既各个.js文件)相对于baseUrl的路径。paths对象的格式是{模块名: .js文件相对于baseUrl的路径}。</p><p>其实可以认为所谓的模块化就是在这里发生的。既paths里通过模块名，关联到了对应的js文件。通过这种形式将js文件”设定”成了模块。</p><h3 id="定义模块"><a href="#定义模块" class="headerlink" title="定义模块"></a>定义模块</h3><p>看一下requirejs里怎么定义模块。打开me.js，定一个me模块：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">var</span> myName = <span class="string">&#x27;Bill&#x27;</span>;</span><br><span class="line">   <span class="keyword">var</span> myJob = <span class="string">&#x27;front-end developer&#x27;</span>;</span><br><span class="line">   <span class="keyword">var</span> mySalary = <span class="string">&#x27;what?&#x27;</span>;</span><br><span class="line">   <span class="keyword">var</span> myTarget = <span class="string">&#x27;become a successful developer&#x27;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> myName;</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="attr">getJob</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> myJob;</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="attr">getSalary</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&#x27;salary is confidential&#x27;</span>;</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="attr">getTarget</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> myTarget;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>就是这么简单，调用define()方法就可以定义模块了(实际上define的英文意思就是“定义“)。向该方法传入一个匿名函数，然后在函数最后返回模块的公共接口。</p><p>同样的，我们再定一个print模块。打开print.js，定义一个模块print。输入以下代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">print</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">console</span>.<span class="property">log</span> &amp;&amp; <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h3><p>模块定义好了，怎么在其他模块中使用呢?</p><p>打开app.js，输入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//[&#x27;me&#x27;,&#x27;print&#x27;]对应require.config()方法传入参数的me和print属性。</span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&#x27;me&#x27;</span>, <span class="string">&#x27;print&#x27;</span>], <span class="keyword">function</span>(<span class="params">me, print</span>) &#123;</span><br><span class="line">  <span class="title function_">print</span>(me.<span class="title function_">getTarget</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到，这个名为app的模块和之前的模块不同，这个模块在调用define方法时传入了两个参数:</p><ul><li>第一个参数是一个数组，在这里是[‘me’, ‘print’]。其中’me’，’print’是require.config()传入的参数中定义的模块名。</li><li>第二个参数是一个匿名函数，这个函数的参数和前面数组里的模块名一一对应。</li></ul><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>现在，用浏览器打开index.html，调出控制台面板(F12或者option+command+i)，就可以在控制台里看到’become a successful developer’这句话了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用requirejs的步骤:</p><ol><li><strong>在页面中的script标签里设置src属性和data-main属性。其中src对应require.js的路径，data-main属性对应入口文件路径，既本文示例中的main.js文件路径。</strong></li><li><strong>在main.js中通过require.confing()配置模块名和模块对应的.js文件路径。</strong></li><li><strong>在main.js中通过require()方法，调用页面的主函数(主模块)，在本文的示例代码中是名为myApp的模块(对应app.js文件)。</strong></li><li><strong>通过define()方法定义模块。</strong></li></ol><p>可以看出requirejs的核心思想，就是把一个个单独的js文件“设定成”模块。然后各个模块间再通过向define()传入模块名，来互相引用。</p><p>本文只介绍了requirejs的一般使用方法，按照本文的做法已经可以在项目中去使用requirejs了。更详细的内容还请参阅<a href="http://requirejs.org/">requirejs官方网站</a>。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> requirejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> requirejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to Check If it is Array?</title>
      <link href="/2015/11/21/checkarray/"/>
      <url>/2015/11/21/checkarray/</url>
      
        <content type="html"><![CDATA[<img src="/images/javascript_logo/js.jpg" class=""><p>Got some instruction about how to check if a variable is Array in JavaScript from this <a href="https://github.com/lxj/javascript.patterns/blob/master/chapter3.markdown">book</a>.</p><p>Here I just copy and record sth to make me more sensitive for how to check Array in JavaScript.</p><p>In the environment which support ES5, just use <em>Array.isArrary()</em>. For example:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>([]); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// trying to fool the check</span></span><br><span class="line"><span class="comment">// with an array-like object</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(&#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">slice</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>In somewhere that no ES5 support, just do this:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Array</span>.<span class="property">isArray</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="title class_">Array</span>.<span class="property">isArray</span> = <span class="keyword">function</span> (<span class="params">arg</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arg) === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用于生成基础样式的base.sass文件</title>
      <link href="/2015/11/16/basesass/"/>
      <url>/2015/11/16/basesass/</url>
      
        <content type="html"><![CDATA[<img src="/images/sass-logo.png" class=""><p>我写了一个base.sass文件用于生成项目中的base.css。你可以在这里看到源码</p><p><a href="https://github.com/buildAll/base.sass-for-base.css/blob/master/base.sass">https://github.com/buildAll/base.sass-for-base.css/blob/master/base.sass</a></p><p>下面贴出base.sass的代码:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @about: base.sass is used to output the common and basic style</span></span><br><span class="line"><span class="comment"> * @author: bill zhao</span></span><br><span class="line"><span class="comment"> * @repo: https://github.com/buildAll/sass_for_base.css</span></span><br><span class="line"><span class="comment"> * @desciption: You can use this code for free, please keep this comments in the file head</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">div</span>,<span class="selector-tag">dl</span>,<span class="selector-tag">dt</span>,<span class="selector-tag">dd</span>,<span class="selector-tag">ul</span>,<span class="selector-tag">ol</span>,<span class="selector-tag">li</span>,<span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>,pre,<span class="selector-tag">form</span>,<span class="selector-tag">fieldset</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>,<span class="selector-tag">p</span>,<span class="selector-tag">blockquote</span>,<span class="selector-tag">th</span>,<span class="selector-tag">td</span></span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span></span><br><span class="line">  padding: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">table</span><br><span class="line">  border-collapse: collapse</span><br><span class="line">  border-spacing: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">fieldset,img</span><br><span class="line">  border: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">address,caption, cite,code,dfn,em,strong,th,var</span><br><span class="line">  font-style: normal</span><br><span class="line">  font-weight: normal</span><br><span class="line"></span><br><span class="line">ol,ul</span><br><span class="line">  list-style: none</span><br><span class="line"></span><br><span class="line">capation,th</span><br><span class="line">  text-align: left</span><br><span class="line"></span><br><span class="line">h1,h2,h3,h4,h5,h6</span><br><span class="line">  font-size: <span class="number">100%</span></span><br><span class="line">  font-weight: normal</span><br><span class="line"></span><br><span class="line">q:before, q:after</span><br><span class="line">  content: <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line">abbr,acronym</span><br><span class="line">  border: <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@each $size in <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">20</span> <span class="number">25</span> <span class="number">30</span></span><br><span class="line">  .f#&#123;$size&#125;</span><br><span class="line">    <span class="attribute">font-size</span>: #&#123;$size&#125;px</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.fb</span></span><br><span class="line">  <span class="attribute">font-weight</span>: bold</span><br><span class="line"></span><br><span class="line">.fn</span><br><span class="line">  font-weight: normal</span><br><span class="line"></span><br><span class="line">@each $indent in <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">  .t#&#123;$indent&#125;</span><br><span class="line">    <span class="attribute">text-indent</span>: #&#123;$indent&#125;<span class="selector-tag">em</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@each</span> $lh, $var in (lh150:<span class="number">150%</span>, lh180:<span class="number">180%</span>,lh200:<span class="number">200%</span>)</span><br><span class="line">  .#&#123;$lh&#125;</span><br><span class="line">    <span class="attribute">line-height</span>: #&#123;$<span class="selector-tag">var</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.unl</span></span><br><span class="line">  <span class="attribute">text-decoration</span>: underline</span><br><span class="line"></span><br><span class="line">.no_unl</span><br><span class="line">  text-decoration: none</span><br><span class="line"></span><br><span class="line">@each $ta, $var in (tl:left, tc:center, tr:right)</span><br><span class="line">  .#&#123;$ta&#125;</span><br><span class="line">    <span class="attribute">text-align</span>: #&#123;$<span class="selector-tag">var</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bc</span></span><br><span class="line">  <span class="attribute">margin-left</span>: auto</span><br><span class="line">  margin-right: auto</span><br><span class="line"></span><br><span class="line">@each $floatname, $var in (fl:left, fr:right)</span><br><span class="line">  .#&#123;$floatname&#125;</span><br><span class="line">    <span class="attribute">float</span>: $var</span><br><span class="line">    display: inline</span><br><span class="line"></span><br><span class="line">@each $clearname, $var in (cb:both, cl:left, cr:right)</span><br><span class="line">  .#&#123;$clearname&#125;</span><br><span class="line">    <span class="attribute">clear</span>: $var</span><br><span class="line"></span><br><span class="line">.clearfix:after</span><br><span class="line">  content: <span class="string">&#x27;.&#x27;</span></span><br><span class="line">  display: block</span><br><span class="line">  height: <span class="number">0</span></span><br><span class="line">  clear: both</span><br><span class="line">  visibility: hidden</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.clearfix</span><br><span class="line">  display: inline-block</span><br><span class="line"></span><br><span class="line">html .clearfix</span><br><span class="line">  height: <span class="number">1%</span></span><br><span class="line"></span><br><span class="line">.vm</span><br><span class="line">  vertical-align: center</span><br><span class="line"></span><br><span class="line">.pr</span><br><span class="line">  position: relative</span><br><span class="line"></span><br><span class="line">.abs-right</span><br><span class="line">  position: absolute</span><br><span class="line">  right: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">.zoom</span><br><span class="line">  zoom: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">.hidden</span><br><span class="line">  visibility: hidden</span><br><span class="line"></span><br><span class="line">.none</span><br><span class="line">  display: none</span><br><span class="line"></span><br><span class="line">@each $width in <span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> <span class="number">50</span> <span class="number">60</span> <span class="number">70</span> <span class="number">80</span> <span class="number">90</span> <span class="number">100</span> <span class="number">200</span> <span class="number">300</span> <span class="number">400</span> <span class="number">500</span> <span class="number">600</span> <span class="number">700</span> <span class="number">800</span></span><br><span class="line">  .w#&#123;$<span class="attribute">width</span>&#125;</span><br><span class="line">    <span class="attribute">width</span>: #&#123;$<span class="attribute">width</span>&#125;px</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.w</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span></span><br><span class="line"></span><br><span class="line">@each $height in <span class="number">50</span> <span class="number">80</span> <span class="number">100</span> <span class="number">200</span></span><br><span class="line">  .h#&#123;$<span class="attribute">height</span>&#125;</span><br><span class="line">    <span class="attribute">height</span>: #&#123;$<span class="attribute">height</span>&#125;px</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.h</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span></span><br><span class="line"></span><br><span class="line">$list: <span class="number">5</span> <span class="number">10</span> <span class="number">15</span> <span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">50</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">@each $m in $list</span><br><span class="line">  .m#&#123;$m&#125;</span><br><span class="line">    <span class="attribute">margin</span>: #&#123;$m&#125;px</span><br><span class="line"></span><br><span class="line"><span class="keyword">@each</span> $mt in $list</span><br><span class="line">  .mt#&#123;$mt&#125;</span><br><span class="line">    <span class="attribute">margin-top</span>: #&#123;$mt&#125;px</span><br><span class="line"></span><br><span class="line"><span class="keyword">@each</span> $mb in $list</span><br><span class="line">  .mb#&#123;$mb&#125;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: #&#123;$mb&#125;px</span><br><span class="line"></span><br><span class="line"><span class="keyword">@each</span> $ml in $list</span><br><span class="line">  .ml#&#123;$ml&#125;</span><br><span class="line">    <span class="attribute">margin-left</span>: #&#123;$ml&#125;px</span><br><span class="line"></span><br><span class="line"><span class="keyword">@each</span> $mr in $list</span><br><span class="line">  .mr#&#123;$mr&#125;</span><br><span class="line">    <span class="attribute">margin-right</span>: #&#123;$mr&#125;px</span><br><span class="line"></span><br><span class="line"><span class="keyword">@each</span> $p in $list</span><br><span class="line">  .p#&#123;$<span class="selector-tag">p</span>&#125;</span><br><span class="line">    <span class="attribute">padding-top</span>: #&#123;$<span class="selector-tag">p</span>&#125;px</span><br><span class="line"></span><br><span class="line"><span class="keyword">@each</span> $pt in $list</span><br><span class="line">  .pt#&#123;$pt&#125;</span><br><span class="line">    <span class="attribute">padding-top</span>: #&#123;$pt&#125;px</span><br><span class="line"></span><br><span class="line"><span class="keyword">@each</span> $pb in $list</span><br><span class="line">  .pb#&#123;$pb&#125;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: #&#123;$pb&#125;px</span><br><span class="line"></span><br><span class="line"><span class="keyword">@each</span> $pl in $list</span><br><span class="line">  .pl#&#123;$pl&#125;</span><br><span class="line">    <span class="attribute">padding-left</span>: #&#123;$pl&#125;px</span><br><span class="line"></span><br><span class="line"><span class="keyword">@each</span> $pr in $list</span><br><span class="line">  .pr#&#123;$pr&#125;</span><br><span class="line">    <span class="attribute">padding-right</span>: #&#123;$pr&#125;px</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
          <category> sass </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用代码说明JavaScript里的继承</title>
      <link href="/2015/11/06/inheritance/"/>
      <url>/2015/11/06/inheritance/</url>
      
        <content type="html"><![CDATA[<img src="/images/javascript_logo/js.jpg" class=""><p>JavaScript是通过prototype来实现继承的。也就是人们常说的”原型继承”。</p><p>本文的目的就是用代码来说明，到底什么是原型继承。</p><h2 id="原型是什么"><a href="#原型是什么" class="headerlink" title="原型是什么"></a>原型是什么</h2><p>JavaScript里有两个“原型”:</p><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>proto<span class="keyword">type</span></span><br><span class="line"><span class="number">2.</span>__proto__</span><br></pre></td></tr></table></figure><p>prototype，是JavaScript里由关键字”function”定义的对象的一个特有的属性，这个属性本身又是一个对象。可能大多数不熟悉原型概念的人看到这句话会有点晕，OK，让我们打开控制台，敲几行代码感受下吧。打开你的chrome浏览器，按F12或者command+option+i，并选中控制台(console)，输入以下代码(注：控制台中可以按ctrl+enter来换行):</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">IamFunction</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;<span class="comment">//定义一个函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">IamFunction</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//打印结果为IamFunction &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">IamObject</span> = &#123;&#125;;<span class="comment">//定义一个对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">IamObject</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//打印结果为undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">IamNumber</span> = <span class="number">0</span>;<span class="comment">//定义一个数字</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">IamNumber</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//打印结果为undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">IamString</span> = <span class="string">&#x27;&#x27;</span>;<span class="comment">//定义一个字符串</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">IamString</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//打印结果为undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">IamArray</span> = [];<span class="comment">//定义一个数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">IamArray</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//打印结果为undefined</span></span><br></pre></td></tr></table></figure><p>由上面的代码可以看出，所谓prototype这个东西，只存在于某个function。(这里并没有检查JavaScript中所有的数据类型上prototype属性，但结果是一样的，你可以自己试一下，只有function类型会有prototype属性。)在上面的例子中，打印结果”IamFunction {}”就表示，prototype就是IamFunction的一个属性，它的默认值是{}。</p><p>除了Function构造的对象上prototype属性，JavaScript里还有一个地方有“原型”，既由构造函数创建的对象的__proto__属性。关于这个__proto__属性，请看下面的内容吧。</p><h2 id="函数的调用方式"><a href="#函数的调用方式" class="headerlink" title="函数的调用方式"></a>函数的调用方式</h2><p>JS里的函数有两种调用方法:普通调用和作为构造函数调用。既：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Func</span>(<span class="params"></span>)&#123;&#125;      <span class="comment">//定义一个函数Func</span></span><br><span class="line"><span class="title class_">Func</span>();                <span class="comment">//普通调用， 没有关键字new</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Func</span>();  <span class="comment">//当作构造函数调用，有关键字new</span></span><br></pre></td></tr></table></figure><p>可以看到两种调用方法字面上的差异是有无关键字new。下面看看两种调用方式的具体区别。</p><p>首先我们定义一个函数Animal。</p><figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义函数Animal</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">animalName</span>)&#123;</span><br><span class="line">   <span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&#x27;function is called&#x27;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.<span class="built_in">log</span>(this);</span><br><span class="line">   <span class="built_in">console</span>.<span class="built_in">log</span>(this.eat);</span><br><span class="line">   this.name = animalName;</span><br><span class="line">   <span class="built_in">console</span>.<span class="built_in">log</span>(this.name);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&#x27;function is going to return&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上文说的，所有的function变量都有prototype属性，所以我们可以这样给prototype属性添加方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给函数Animal的prototype属性添加eat方法</span></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;eating&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先来看普通调用的情况:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下是A行</span></span><br><span class="line"><span class="keyword">var</span> dog = <span class="title class_">Animal</span>(<span class="string">&#x27;dog&#x27;</span>);  <span class="comment">//调用函数Animal，未使用new  ******* A ******</span></span><br><span class="line">                          <span class="comment">//上面这行代码的意思可以理解为：调用Animal函数，并把返回值赋给变量dog;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog);         <span class="comment">//打印结果为undefined</span></span><br><span class="line"><span class="comment">/*******</span></span><br><span class="line"><span class="comment">* 对于上面这行打印结果的解释:变量dog的值为undefined是因为函数Animal的定义的最后并没有写上return，既函数本身没有任何返回值，既undefined</span></span><br><span class="line"><span class="comment">******/</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">name</span>); <span class="comment">//打印结果为dog。对于这个打印的解释请往下看。</span></span><br></pre></td></tr></table></figure><p>让我们看看在上面A行调用过程中，到底发生了什么。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">animalName</span>)&#123;</span><br><span class="line"></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;function is called&#x27;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);  <span class="comment">//打印结果为Window &#123;external: Object, chrome: Object, document: document, dog: undefined, speechSynthesis: SpeechSynthesis…&#125;</span></span><br><span class="line">   <span class="comment">/******</span></span><br><span class="line"><span class="comment">   *  对于以上面这行打印结果的解释： 这里打印的是对象window。window对象是由浏览器用类似下面的代码自动创建的</span></span><br><span class="line"><span class="comment">   *  var window = new Window();</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *  因为A行是直接在全局作用域调、既window对象上调用了Animal(&#x27;dog&#x27;)，所以this引用的是window对象。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *  既JavaScript内部执行了类似这样的代码:</span></span><br><span class="line"><span class="comment">   *  this = window;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   ******/</span></span><br><span class="line"></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">eat</span>);   <span class="comment">//打印结果为undefined。这是由于this引用了window，而window本身并没有eat方法。</span></span><br><span class="line"></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = animalName;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);  <span class="comment">//打印结果为dog。因为上面一行将函数参数animalName的值，也就是&#x27;dog&#x27;赋给this.name，所以这里打印出&#x27;dog&#x27;。</span></span><br><span class="line">                            <span class="comment">//再次注意这里的this已经引用了对象window，所以给this添加name属性既给window添加了name属性。</span></span><br><span class="line"></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;function is going to return&#x27;</span>);</span><br><span class="line">   <span class="comment">// 函数体的最后并没有显性的写上return;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看使用new关键字调用Animal时会发生什么：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下是B行</span></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;dog&#x27;</span>); <span class="comment">//在Animal的调用前使用了关键字new，则此时Animal函数成为了构造函数。  ********* B *********</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog);            <span class="comment">//打印结果为 Animal &#123;name: &quot;dog&quot;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">name</span>)     <span class="comment">//打印结果为undefined;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>B行在函数Animal的调用Animal()前加上了关键字new，像这样在函数调用前加上new，此时函数就被当作构造函数使用了。这里的”构造”过程如下:</p><p>1.在JavaScript内部，new会创建一个对象{}。你可以想象成JavaScript内部执行了这样一行代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newObject = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>2.这个对象的__proto__属性随即引用了Animal的prototype属性。你可以想像成JavaScript内部执行了这样的代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(newObject, <span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>);  <span class="comment">//设置newObject的__proto__属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面一行也可以写成newObject.__proto__ = Animal.prototype。</span></span><br><span class="line"><span class="comment">// __proto__是JavaScript对象里特有的属性，它引用构造函数的prototype属性。</span></span><br><span class="line"><span class="comment">// 你可以这样访问__proto__属性，Object.getPrototypeOf(newObject)，或者newObject.__proto__;</span></span><br></pre></td></tr></table></figure><p>3.随即发生了类似这样的操作:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Animal</span>.<span class="title function_">call</span>(newObject, <span class="string">&#x27;dog&#x27;</span>); <span class="comment">//这里相当于使用了函数的call方法改变了函数内部this的指向。</span></span><br></pre></td></tr></table></figure><p>4.最后，这个由new创建的对象会被函数返回，既</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"><span class="string">&#x27;dog&#x27;</span></span>)&#123;</span><br><span class="line"></span><br><span class="line">  newObject.<span class="property">name</span> = <span class="string">&#x27;dog&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> newObject;        <span class="comment">//相当于JavaScript内部自动给我们的函数定义添加了一句return this;注意，只有当有new关键字出现时，才会自动添加这句。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的看一下B行调用Animal的过程中，发生了什么：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">animalName</span>)&#123;</span><br><span class="line"></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;function is called&#x27;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);  <span class="comment">//打印结果为 &gt; Animal &#123;&#125;</span></span><br><span class="line">   <span class="comment">/******</span></span><br><span class="line"><span class="comment">   * 调用对象被new关键字设置为了newObject，所以这里打印的是&#123;&#125;, 前面的&quot;Animal&quot; 是告诉你这个&#123;&#125;的构造函数为Animal</span></span><br><span class="line"><span class="comment">   * 而由于作用域中有 this.name = animalName这行代码，所以如果你点击该行打印结果前面的箭头展开这个对象，你会看到这个&#123;&#125;已经具备了name属性。关于作用域，这里就不展开说了。</span></span><br><span class="line"><span class="comment">   ******/</span></span><br><span class="line"></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">eat</span>);   <span class="comment">//打印结果为function()&#123;console.log(&#x27;eating&#x27;)&#125;</span></span><br><span class="line">   <span class="comment">/*****</span></span><br><span class="line"><span class="comment">   * 上文中的构造过程第2步中已经说明newObject的__proto__属性引用了Animal.prototype属性。</span></span><br><span class="line"><span class="comment">   * 这里的eat方法正是来自于__proto__属性。而JavaScript中规定，只要是__proto__上的属性，都可以省略__proto__，直接通过newObject.eat来访问。</span></span><br><span class="line"><span class="comment">   ***/</span></span><br><span class="line"></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = animalName;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);  <span class="comment">//打印结果为dog。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;function is going to return&#x27;</span>);</span><br><span class="line">   <span class="comment">// 函数体的最后并没有显性的写上return;</span></span><br><span class="line">   <span class="comment">// 但是由于用new关键字调用了函数Animal，所以这里相当于执行了 return this;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="典型的继承写法"><a href="#典型的继承写法" class="headerlink" title="典型的继承写法"></a>典型的继承写法</h2><p>先总结一下上文出现的概念:</p><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="type">JavaScript</span>里的函数都有proto<span class="keyword">type</span>属性。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>对象都有__proto__属性。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>对象的__proto__属性引用创建其的构造函数的proto<span class="keyword">type</span>属性。</span><br></pre></td></tr></table></figure><p>如果理解了上面的这三条概念，那么就不难理解继承了。我们来看JavaScript里典型的继承写法:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">animalName</span>)&#123;        <span class="comment">//定义函数Animal</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = animalName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;  <span class="comment">//给Animal的prototype属性添加eat方法</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;eating&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>)&#123;&#125;                    <span class="comment">//定义函数Dog</span></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;dog&#x27;</span>);  <span class="comment">//将函数Dog的prototype属性引用为函数Animal&quot;构造&quot;的对象，这步是重点，继承在这里发生了。</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>);         <span class="comment">//打印结果为 Animal &#123;name:&#x27;dog&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span>);    <span class="comment">//打印结果为&#x27;dog&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">eat</span>());   <span class="comment">//打印结果为&#x27;eating&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">hasOwnPropety</span>(<span class="string">&#x27;name&#x27;</span>))          <span class="comment">// 打印 true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">hasOwnPropety</span>(<span class="string">&#x27;eat&#x27;</span>))           <span class="comment">// 打印 false。上面虽然调用eat方法成功了，但是令人意外的是Dog.prototype本身并没有eat方法。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>.<span class="title function_">hasOwnPropety</span>(<span class="string">&#x27;eat&#x27;</span>)) <span class="comment">// 打印 true</span></span><br></pre></td></tr></table></figure><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I can eat&#x27;</span>);&#125;;       <span class="comment">//给Animal的原型添加eat方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Human</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Human</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"><span class="comment">//这行代码可以拆成两行理解，</span></span><br><span class="line"><span class="comment">//var animal = new Animal; 此时animal.__proto__引用自Animal.prototype，既animal.__proto__.hasOwnPropety(&#x27;eat&#x27;)返回true</span></span><br><span class="line"><span class="comment">//Human.prototype = animal; 此时Human.prototype.__proto__.hasOwnPropety(&#x27;eat&#x27;)返回true</span></span><br><span class="line"><span class="comment">//则有 Human.prototype.__proto__.eat(); 打印 I can eat</span></span><br><span class="line"><span class="comment">//而JS中可以省略__proto__直接用&quot;.&quot;去访问__proto__上的属性，所以这时候可以像这样调用eat方法：</span></span><br><span class="line"><span class="comment">//Human.prototype.eat(); 打印 I can eat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以应该可以理解下面的代码了:</span></span><br><span class="line"><span class="comment">//var someone = new Human();</span></span><br><span class="line"><span class="comment">//上面的new构造过程包括了这样的操作: someone.__proto__ = Human.prototype;</span></span><br><span class="line"><span class="comment">//既someone.__proto__ = animal;</span></span><br><span class="line"><span class="comment">//则有:</span></span><br><span class="line"><span class="comment">//someone.__proto__.__proto__.eat(); 打印 I can eat。</span></span><br><span class="line"><span class="comment">//省略__proto__后</span></span><br><span class="line"><span class="comment">//someone.eat();  I can eat</span></span><br><span class="line"><span class="comment">//既someone对象继承了Animal上的eat方法。</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Human</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">speak</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I can speak&#x27;</span>);&#125;;    <span class="comment">//此时Human.prototype这个由Animal构造的对象拥有了speak方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Coder</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Coder</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Human</span>();</span><br><span class="line"><span class="title class_">Coder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">coding</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I can coding&#x27;</span>);&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">JSer</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">JSer</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Coder</span>();</span><br><span class="line"><span class="title class_">JSer</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">codingInJS</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I can conding in JS&#x27;</span>);&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = <span class="keyword">new</span> <span class="title class_">JSer</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//原型链来了：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me)                                                              <span class="comment">//打印结果为JSer &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me.<span class="property">__proto__</span>);                                                   <span class="comment">//打印结果为Coder &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me.<span class="property">__proto__</span>.<span class="property">__proto__</span>);                                         <span class="comment">//打印结果为Human &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>);                               <span class="comment">//打印结果为Animal &#123;&#125;, 拥有speak方法的Animal构造出的对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>);                     <span class="comment">//打印结果为Animal &#123;&#125;, 没有speak方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>);           <span class="comment">//打印结果为Object &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>); <span class="comment">//打印结果为null，此时原型链到达尽头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下调用均省略了__proto__属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me.<span class="title function_">eat</span>());                                              <span class="comment">//打印I can eat 。eat继承自构造函数Animal</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me.<span class="title function_">speak</span>());                                            <span class="comment">//打印I can speak。speak方法继承自构造函数Human</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me.<span class="title function_">coding</span>());                                           <span class="comment">//打印I can coding。 coding方法继承自构造函数Coder</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me.<span class="title function_">codingInJS</span>());                                       <span class="comment">//打印I can coding in JS。 codingInJS方法继承自构造函数JSer</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>JavaScript通过设置构造函数的prototype对象，从而决定了通过new构造出来的对象的__proto__属性。</li><li>因为每个对象都具备__proto__属性，从而实现了一条原型链。</li><li>又因为JavaScript可以省略__proto__去调用__proto__属性上的方法，所以我们就可以轻松的访问整条原型链上的属性了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手动给你的GitHub项目设置一个主页</title>
      <link href="/2015/10/23/%E6%89%8B%E5%8A%A8%E7%BB%99%E4%BD%A0%E7%9A%84GitHub%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%A1%B5/"/>
      <url>/2015/10/23/%E6%89%8B%E5%8A%A8%E7%BB%99%E4%BD%A0%E7%9A%84GitHub%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<img src="/images/github-logo.png" class=""><p>你在GitHub上建立的每个项目(repository)都是可以拥有独立的主页的， 如果你还不知道如何完成这件事，希望这篇文章对你有所帮助。</p><p>GitHub官网有英文版的教程， <a href="https://help.github.com/articles/creating-project-pages-manually/">Creating Project Pages manually</a>。如果你不喜欢读英文的文章，那么就继续往下读吧。</p><h2 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h2><p>项目的主页需要在当前项目上创建一个特殊的、独立的分支，先克隆项目：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> github.com/user/repository.git</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">克隆需要创建主页的项目</span></span><br><span class="line">Cloning into &#x27;repository&#x27;...</span><br><span class="line">remote: Counting objects: 2791, done.</span><br><span class="line">remote: Compressing objects: 100% (1225/1225), done.</span><br><span class="line">remote: Total 2791 (delta 1722), reused 2513 (delta 1493)</span><br><span class="line">Receiving objects: 100% (2791/2791), 3.77 MiB | 969 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (1722/1722), done.</span><br></pre></td></tr></table></figure><h2 id="建立gh-pages分支"><a href="#建立gh-pages分支" class="headerlink" title="建立gh-pages分支"></a>建立gh-pages分支</h2><p>克隆完成后建立分支，注意分支的名字必须是__gh-pages__：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> repository</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout --orphan gh-pages</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建用于存放主页内容的分支，注意使用 --orphan</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到分支 <span class="string">&#x27;gh-pages&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> -rf .</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清除工作目录下所有的内容</span></span><br></pre></td></tr></table></figure><h2 id="添加内容并提交"><a href="#添加内容并提交" class="headerlink" title="添加内容并提交"></a>添加内容并提交</h2><p>现在你有了一个空的工作目录，现在要做的是往这个目录里添加你主页的内容(html&#x2F;js&#x2F;css)，下面这段可以供你测试：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;My Page&quot; &gt; index.html</span><br><span class="line">git add index.html</span><br><span class="line">git commit -a -m &quot;First pages commit&quot;</span><br><span class="line">git push origin gh-pages</span><br></pre></td></tr></table></figure><p>此时你项目的主页应该已经可以访问了。如果这步操作失败了，你注册GitHub的邮箱应该会收到一封提示邮件。</p><h2 id="访问主页"><a href="#访问主页" class="headerlink" title="访问主页"></a>访问主页</h2><p>尝试访问吧，链接是这样的</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http(s)://&lt;username&gt;.github.io/&lt;projectname&gt;</span><br></pre></td></tr></table></figure><p>注意，不管你的项目仓库是否是私有的，这个主页都是对所有人开放的。</p><p>–END–</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的旧博客地址</title>
      <link href="/2015/10/22/oldBlog/"/>
      <url>/2015/10/22/oldBlog/</url>
      
        <content type="html"><![CDATA[<img src="/images/default.png" class=""><p>这里是我的<a href="http://blog.csdn.net/developer_biao">旧的博客</a>地址：<a href="http://blog.csdn.net/developer_biao">http://blog.csdn.net/developer_biao</a></p>]]></content>
      
      
      <categories>
          
          <category> 旧博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旧博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
